{"componentChunkName":"component---src-pages-index-tsx","path":"/","result":{"data":{"allMdx":{"nodes":[{"id":"c6c4b8e9-346b-54e3-bc26-219a75d0d6d3","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Confusable methods\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Multiple methods with confusably-similar names and effects\"), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"A class or namespace has two functions with similar names. A programmer who wants the functionality of the first function may mistakenly call the second. If the effects are similar, casual testing may mislead the programmer into thinking they had called the correct function, even if the two functions differ in some important way.\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"The classic example of this is the confusion between \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Thread.start()\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Thread.run()\"), \" in Java. Python's standard thread package was based on Java's, and also has this problem. For example, consider these snippets:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"Thread myThread = new Thread(() => doSomethingExpensive());\\nmyThread.run();\\n\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"class MyThread(thread):\\n  def run(self):\\n    doSomethingExpensive()\\n\\nmyThread = MyThread()\\nmyThread.run()\\n\")), mdx(\"p\", null, \"In both of these, the programmer intended to call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"myThread.start()\"), \", which creates a new background thread and then runs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomethingExpensive\"), \" on that background thread. Instead, they have called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"myThread.run()\"), \", which runs \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomethingExpensive()\"), \" in the current thread. This happened because \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"start\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"run\"), \" are confusingly similar names. Further, the application will appear to work, but it will be slower because something which should be done in the background is blocking important behavior. Because of that, this bug can go undetected in a codebase for a long time.\"), mdx(\"p\", null, \"For another example, consider the battle between the various \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" functions in PyYAML. Originally, in versions 3.12 and below, PyYAML had two functions called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"safe_load\"), \", where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"safe_load\"), \" had a safe behavior while \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" could execute arbitrary code. In PyYAML 4.1, they renamed the old \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"danger_load\"), \". They removed the old \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"safe_load\"), \" function and created a new \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" function, which is also unsafe. This caused significant controversy. The story is chronicled in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.serendipidata.com/posts/safe-api-design-and-pyyaml\"\n  }, \"this blog post\"), \".\"), mdx(\"p\", null, \"Both pairs of functions raised issues of confusability. Users of a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" will see YAML parse correctly and believe they have implemented this functionality correctly, but they have in fact introduced an arbitrary-code-execution vulnerability into their software. And when there is a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"danger_load\"), \", a programmer may be tempted to think that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" function implements the safer options, but in this library \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" was in some ways more dangerous than \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"danger_load\"), \".\"), mdx(\"h2\", null, \"Discussion and Lessons\"), mdx(\"p\", null, \"Having confusable methods is one way to violate the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/@note89/state-of-emergency-the-four-ways-your-state-might-be-wrong-b6cebea38d78\"\n  }, \"Representable/Valid Principle\"), \", that there should be a 1-1 mapping between representable and valid states of the program. For the thread example, the state where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"doSomethingExpensive()\"), \" has been run in the main thread is an error state which should never occur. It should not be possible to call the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Thread.run()\"), \" method. In PyYAML 3.12, calling \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" enters a state where arbitrary code may have been executed, which is invalid; it should therefore not be possible for a programmer to inadvertently call it. In comparison, after the changes of version 4.1, an ordinary programmer would only call \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" and never \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"danger_load\"), \", meaning the result of having called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"danger_load\"), \" is not representable in any program surviving minimal code review. However, this only makes uses of the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load\"), \" function more likely to pass code review, even though it is also insecure.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Confusable methods"}},{"id":"c09f7a4c-d877-5060-b2ed-da6e693197d0","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Missing impled return type\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Missing implied return type\"), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"The name of a function strongly suggests a return type, but the function has no return value\"), mdx(\"h2\", null, \"Examples and subtypes\"), mdx(\"p\", null, \"This antipattern contains as special cases many of the antipatterns catalogued by Arnaoudova's original work. It includes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.2]\", \" \\\"Validation\\\" methods with \\\"check\\\" or \\\"validate\\\" in their name that neither return a value nor raise an exception. Example (\", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UMLComboBox.checkCollision\"), \" from ArgoUML):\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public void checkCollision(final String before,\\n                           final String after) {\\n    final boolean collision = before != null\\n           && before.equals(this._shortName) || after != null\\n           && after.equals(this._shortName);\\n    if (collision) {\\n        if (this._longName == null) {\\n            this._longName = this.getLongName();\\n        }\\n        this._displayName = this._longName;\\n    }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.3]\", \" Methods of the form \\\"getSomething\\\" which do not return a value. Example (from Eclipse 1.0):\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"protected void getMethodBodies(\\n        final CompilationUnitDeclaration unit,\\n        final int place) {\\n    // fill the methods bodies in order for the code\\n    // to be generated\\n    if (unit.ignoreMethodBodies) {\\n        unit.ignoreFurtherInvestigation = true;\\n        return; // if initial diet parse did not work,\\n        // no need to dig into method bodies.\\n    }\\n    if (place < this.parseThreshold) {\\n        return; // work already done ...\\n    }\\n    // real parse of the method....\\n    this.parser.scanner\\n           .setSourceBuffer(\\n                   unit.compilationResult.compilationUnit\\n                   .getContents());\\n    if (unit.types != null) {\\n        for (int i = unit.types.length; --i >= 0;) {\\n             unit.types[i].parseMethod(this.parser, unit);\\n        }\\n    }\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.5]\", \" Methods whose name suggests a transformation do not return a value (and where the documentation does not explain where the result is stored). Example:\")), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-java\"\n  }, \"public void javaToNative(final Object object,\\n            final TransferData transferData) {\\n    final byte[] check =\\n            LocalSelectionTransfer.TYPE_NAME.getBytes();\\n    super.javaToNative(check, transferData);\\n}\\n\")), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.7]\", \" A method named \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"getSomething\"), \" returns nothing. (This one is absent from Arnaoudova's first papers, but is present in \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"http://veneraarnaoudova.ca/wp-content/uploads/2018/03/2018-ICPC-Effect-lexicon-cognitive-load.pdf\"\n  }, \"the 2018 paper\"), \".)\")), mdx(\"h2\", null, \"Discussion and Lessons\"), mdx(\"p\", null, \"This anti-pattern is relatively benign, at least in a statically typed language: a program which attempts to use the nonexistent return value cannot be written. But outside of being intrinsically confusing, it also suggests the codebase relies too heavily on mutation. A discussion of the perils of mutable code is outside the scope of this document.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Missing impled return type"}},{"id":"e63362a1-b55a-5758-bcef-19d53f774178","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Inappropriately specific name\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Inappropriately-specific name\"), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"The name of a field or function implies it is for a single usecase. However, the usage of that field or function is more general.\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"The most common example is when a class that could be of general interest has a name prefixed with the framework or application it is part of. For example, the Spring Framework's \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/test/context/junit4/statements/SpringRepeat.html\"\n  }, \"SpringRepeat\"), \" class is a helper class for generic test harnesses, and does not contain anything specific to Spring and could be of interest to other applications. However, its name implies that it is. This makes it harder to separate from Spring, such as by trying to migrate it into the underlying unit testing framework.\"), mdx(\"p\", null, \"Another kind of example is when a name refers to something specific about how a value is intended to be used, even when the code itself depends on no such assumption. As a toy example, a function which appends some text to a message may take a string parameter named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"englishText\"), \", even though nothing in the code cares about what language the string is in. When the application is internationalized, this name will need to change, or else the code will be misleading. For a real instance of this, one former Mirdin student writes:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"I had an input field which was designed to store and validate email addresses, so I had email in my code in things\\nlike \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emailInput\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emailInputValidation\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"handleEmailIputChange\"), \" around my code. However, the specification\\njust changed to disallow emails, all of these items are going to be user ids instead we just learned the client's\\nusers would not be allowed to use email addresses. I should have hidden the knowledge that these input values\\nwere likely going to be emails, and instead made it something like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"userIdentifier\"), \" or something similar\")), mdx(\"p\", null, \"A similar example, from another former Mirdin student:\"), mdx(\"blockquote\", null, mdx(\"p\", {\n    parentName: \"blockquote\"\n  }, \"Worked on GDPR project. Had internal database column names such as \\\"gdpr_blah.\\\" These\\nsomehow wound up in reports seen by legal, who requested they be changed to \\\"privacy_blah.\\\"\")), mdx(\"p\", null, \"While the observed symptom is most directly caused by internal database column names leaking, it is likely that these fields will be reused for handling other privacy legislation, such as California's CCPA. At that point, the column names will be very confusing if not changed.\"), mdx(\"h2\", null, \"Discussion and Lessons\"), mdx(\"p\", null, \"According to the Parnas subset criteria, formulated by David Parnas \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://courses.cs.washington.edu/courses/cse503/08wi/parnas-1979.pdf\"\n  }, \"in 1979\"), \", component A should not depend on component B if there is a useful subset of the program which contains A but not B. A class named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"SpringRepeat\"), \" does depend on Spring \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.jameskoppel.com/files/papers/demystifying_dependence.pdf\"\n  }, \"in naming\"), \", even though it is useful independent of Spring. This kind of naming thus violates the Parnas subset criteria.\"), mdx(\"p\", null, \"Now consider names such as \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"englishText\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"emailInput\"), \" for variables which are actually for arbitrary text and some unknown user ID. These names reflect assumptions made in the rest of the codebase, and therefore need to change when those assumptions change. Reducing the spread of assumptions is a general principle for making code more flexible in the face of unknown future changes.  It is better for the facts about what kind of text or ID will be used to be considered \\\"secrets\\\" of a different part of the code.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Inappropriately specific name"}},{"id":"c6779339-8522-5618-97af-a5a4e56b9ef8","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Name/Type Mismatch\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Name/Type Mismatch\"), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"The name of a function strongly suggests a return type, but the function has a different type.\"), mdx(\"p\", null, \"Alternatively, the name of a parameter suggests a type, but the parameter has a different type.\"), mdx(\"p\", null, \"Alternatively, the name of a field strongly suggests its type, but the field has a different type.\"), mdx(\"h2\", null, \"Examples and subtypes\"), mdx(\"p\", null, \"Perhaps the most infamous example of this antipattern is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"CURLOPT_SSL_VERIFYHOST\"), \". Many programmers assumed this parameter took a boolean and supplied \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \". In fact, it took either \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0\"), \", \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \", or \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \", where only \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"2\"), \" provided full security. Since \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" is equivalent to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"1\"), \" in C, the many programs which supplied \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"true\"), \" were vulnerable to man-in-the-middle attacks. This is described in a paper called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.cs.utexas.edu/~shmat/shmat_ccs12.pdf\"\n  }, \"The Most Dangerous Code in the World\"), \".\"), mdx(\"p\", null, \"Outside of that, this antipattern contains as special cases a majority of the antipatterns catalogued by Arnaoudova's original work. It includes:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[A.2]\", \" Methods of the form \\\"isSomething\\\" whose return is not a boolean\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[A.3]\", \" Methods of the form \\\"setSomething\\\" with a non-void return type (not explained in documentation)\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[A.4]\", \" Methods whose name is singular, but which return a collection\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.4]\", \" Methods whose name is a predicate (like \\\"shouldFoo\\\"), but whose return is not a boolean\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.6]\", \" Methods whose name is plural, which which do not return a collection.\\n** A few exceptions have been noted, such as people expecting that the name \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"getBounds\"), \" returns a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Dimension\"), \".\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[C.1]\", \" The method name contains an antonym of a word in its return type (e.g.: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"ControlEnableState disable(...)\"), \", example found in Eclipse 1.0).nnn\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[D.1]\", \" Field name which is singular but which is actually a collection (e.g.: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"Vector target\"), \").\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[D.2]\", \" Field name suggests a boolean, but type is non-boolean (e.g.: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"int[] reached\"), \").\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[E.1]\", \" Field name is plural, but its type is not a collection (e.g.: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"boolean _stats\"), \", example found in ArgoUML 0.10.1).\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[F.1]\", \" Field name and type contain antonyms (such as the declaration \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"MAssociationEnd start\"), \", example found in ArgoUML 0.10.1).\")), mdx(\"h2\", null, \"Discussion and Lessons\"), mdx(\"p\", null, \"For writing code, this anti-pattern is relatively benign in languages with strict typing rules. If code is written incorrectly expecting the wrong type, it is unlikely to compile. But as seen above, in cases where it does, such as caused by C allowing confusion of integers, booleans, and enums, the cost can be deadly.\"), mdx(\"p\", null, \"In languages with looser typing constraints, code which mistakenly assumes the wrong type is more likely to linger. A potentially-deadly example: writing code like \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"if shouldFoo()\"), \" where \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"shouldFoo()\"), \" returns an object rather than a boolean. In Ruby or Python, this code will look correct, but in fact the if-statement will always be taken.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Name/Type Mismatch"}},{"id":"0512af92-4544-5a52-a7b9-f5e7d6ac8baa","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Incorrect associated spec\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Name is strongly associated with an inapplicable specification\"), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"A function has a name which strongly implies it has some property which the function does not.\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"Certain names very strongly indicate common pre- and postconditions for a function. It is an antipattern to use those names for functions which lack those pre- and postconditions.\"), mdx(\"p\", null, \"Examples of how a name implies a certain specification:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A function called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"init\"), \" will enable many other functions to be called, which otherwise could not be called.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A function called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"open\"), \" must be called before calling a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"read\"), \" or \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"write\"), \" function, and is paired with a \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"close\"), \" function.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"A function called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"validate\"), \" will raise an exception or return some kind of error value if its input is somehow invalid.\")), mdx(\"p\", null, \"As an example of this antipattern, the name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"connect\"), \" strongly implies that it creates a connection object which will be shared across future requests. However, this is not what \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Database.connect\"), \" does in Ktorm, a Kotlin library for building typesafe SQL queries. While the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.ktorm.org/en/connect-to-databases.html#Connect-with-a-URL\"\n  }, \"docs recommend\"), \" writing\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-kotlin\"\n  }, \"val database = Database.connect(\\n    url = \\\"jdbc:mysql://localhost:3306/ktorm\\\",\\n    driver = \\\"com.mysql.jdbc.Driver\\\",\\n    user = \\\"root\\\",\\n    password = \\\"***\\\"\\n)\\n\")), mdx(\"p\", null, \"what this actually does is save credentials that will be used to create a new connection for every request thereafter. This is a performance bug. A more accurate name for the operation would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Database.withCredentials\"), \".\"), mdx(\"p\", null, \"A similar example is found in the internal \\\"service communication layer\\\" of a major software company, which we will refer to by the pseudonym \\\"Odrin.\\\" In Odrin, the function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createAsyncRequest\"), \" sounds like it creates a request. However, it instead creates a request template; the actual arguments should be passed to this template.\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-typescript\"\n  }, \"const odrinCall = deps.odrin.createAsyncRequest(requestDefinition);\\nconst result = await odrinCall() // wrong\\n// should be:\\n// const result = await odrinCall({data: data, request: requestBody}}) \\ncb(result);\\n\")), mdx(\"p\", null, \"As a result of this issue, one former Mirdin student reported spending an entire week trying to figure out why an RPC call was \\\"failing silently,\\\" and had half the backend team look at it. A more accurate name for this operation would be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"compileAsyncRequest\"), \". Note that this problem was exacerbated by lack of strict typing, and by the philosophy that the incorrect calls to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"createAsyncRequest\"), \" (erroneously passing in the request arguments) and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"odrinCall()\"), \" (not passing in the request arguments) should nonetheless be made to succeed (an application of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Robustness_principle\"\n  }, \"Postel's law\"), \").\"), mdx(\"h3\", null, \"Subtypes\"), mdx(\"p\", null, \"This anti-pattern has significant overlap with the anti-pattern of name/type mismatch. Further, at least of one the antipatterns catalogued by Arnaoudova arguably falls in this category:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[B.2]\", \": \\\"Validation\\\" methods with \\\"check\\\" or \\\"validate\\\" in their name that neither return a value nor raise an exception. Arnaoudova's example is \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"UMLComboBox.checkCollision\"), \" from ArgoUML, which has signature \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"public void checkCollision(String before, String after)\"), \" and does not raise any exception.\")), mdx(\"p\", null, \"Additionally, the anti-pattern of \\\"Unexpected Side Effects\\\" could be considered a subtype of this antipattern, except that the discussion here focuses on expected-but-missing properties of what a function does, whereas \\\"Unexpected Side Effects\\\" is about expected-but-missing properties of what a function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"doesn't\"), \" do.\"), mdx(\"h2\", null, \"Discussion and Lessons\"), mdx(\"p\", null, \"The discussion of \\\"errors of modular reasoning\\\" under \\\"Unexpected Side Effects\\\" applies here as well. If a function \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" calls another function which suffers from this antipattern, then a programmer will need to read the callees to know that the function is correct, as opposed to only reading \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"foo\"), \" itself and the names/documentation of its callees.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Incorrect associated spec"}},{"id":"024f2fe9-2d6c-55ae-939c-9a2dbdf796ea","body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Unexpected Side Effects\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h1\", null, \"Unexpected Side Effects\"), mdx(\"h2\", null, \"Description\"), mdx(\"p\", null, \"The name of a function suggests that it is pure, but it actually has an effect such as modifying some shared state or raising an exception.\"), mdx(\"h2\", null, \"Examples\"), mdx(\"p\", null, \"Neither the name nor documentation of Django's public \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"get_wsgi_application\"), \" function suggests it does anything more than return a value, nor does a quick glance at its code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"def get_wsgi_application():\\n    \\\"\\\"\\\"\\n    The public interface to Django's WSGI support. Return a WSGI callable.\\n    Avoids making django.core.handlers.WSGIHandler a public API, in case the\\n    internal WSGI implementation changes or moves in the future.\\n    \\\"\\\"\\\"\\n    django.setup(set_prefix=False)\\n    return WSGIHandler()\\n\")), mdx(\"p\", null, \"However, deeper inspection shows that it affects the global state, including calling a function called \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"load_middleware\"), \". There are multiple example usages (taken from \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://python.hotexamples.com/examples/django.core.wsgi/-/get_wsgi_application/python-get_wsgi_application-function-examples.html\"\n  }, \"here\"), \") of it being used purely for effects. For example:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-python\"\n  }, \"# Loads the django Models\\nget_wsgi_application()\\n# Once loaded we can reference them\\nfrom photologue.models import Photo\\nfrom photologue.models import Gallery\\n\")), mdx(\"p\", null, \"(\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/buildcom/fabric-remote-dashboard/blob/d77ed1b313cc2faa5f4e4fd027847b6379ea14f7/fabfile.py#L254\"\n  }, \"source\"), \")\"), mdx(\"p\", null, \"For another example, the author, while an intern at Facebook in 2010, encountered a situation where a method named \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSomething\"), \" would actually save a value in the database. This was actually benign, as there was a fixed set of rows in this table, which represented the fixed set of data sources available for use in automated-moderation rules. However, the author's project actually made this set of data sources runtime-extensible, and use of that \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"getSomething\"), \" method caused a bug where creating a new data source but then hitting \\\"cancel\\\" would result in it being created anyway.\"), mdx(\"h2\", null, \"Subtypes\"), mdx(\"p\", null, \"Two of Arnaoudova's original examples overlap heavily with this antipattern:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[A.1]\", \": Methods of the form \\\"getSomething\\\" which have effects beyond returning an attribute\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"[A.3]\", \": Methods of the form \\\"setSomething\\\" which have effects other than setting an attribute.\", mdx(\"ul\", {\n    parentName: \"li\"\n  }, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Arnaoudova's formulation is a bit broader. Her primary example is actually a method called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"setBreadth\"), \" which does not set anything but does construct a modified version of the original object. It would more properly be called \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"withBreadth\"), \".\")))), mdx(\"h2\", null, \"Discussion and Lessons\"), mdx(\"p\", null, \"In program verification, and more broadly in artificial intelligence and philosophy, the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"frame\"), \" of an action is the set of things that may be reasonably modified by it. Giving functions a narrow frame is important so that, when there is a problem, the programmer needs only think about a few things that could cause the problem. In this antipattern, the name of the function suggests a narrow frame, but the function breaks out of the frame.\"), mdx(\"p\", null, \"For a great discussion, see \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://folk.idi.ntnu.no/gamback/teaching/TDT4138/dennett84.pdf\"\n  }, \"this essay\"), \" by Daniel Dennett.\"), mdx(\"p\", null, \"As an example of what can go wrong: the name of these functions implies that a valid implementation would have no side effects. It would therefore be valid to change the function to remove the side effects. However, other code may depend on these effects, even though they are not guaranteed, and so making what should be a benign change can cause other code to break. The previous code could be said to contain an \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.pathsensitive.com/2018/01/the-three-levels-of-software-why-code.html\"\n  }, \"error of modular reasoning\"), \": a method that works for all inputs, but where a programmer would need to read large chunks of the codebase to ascertain that this method works and could not do so just by reading the method and the names/documentation of its dependences.\"));\n}\n;\nMDXContent.isMDXComponent = true;","frontmatter":{"title":"Unexpected Side Effects"}}]}},"pageContext":{}},"staticQueryHashes":["1946181227"]}